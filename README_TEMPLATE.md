# __PROJECT_NAME__

[![CI](https://github.com/__REPO_SLUG__/actions/workflows/ci.yml/badge.svg?branch=master)](https://github.com/__REPO_SLUG__/actions/workflows/ci.yml)
[![Bun](https://img.shields.io/badge/bun-1.x-000)](https://bun.sh)

> Visibility: **__VISIBILITY__** • Package: `__PKG_NAME__`

A minimal, fast Bun + TypeScript project scaffold with consistent tooling:

> **Default branch:** Repos created from this template inherit the `master` branch. Rename it to `main` after initialization if that matches your workflow.

- TypeScript (ESM, strict)
- ESLint + Prettier for linting/formatting
- Bun test runner
- Husky + lint-staged pre-commit checks
- GitHub Actions CI (typecheck, lint, test)
- Build & metadata tooling: `bun run build` drives `zshy` (configured via the `"zshy"` key in package.json) to emit dual CJS/ESM bundles; CI also runs `bun run build` to regenerate `package.json` metadata and catch drift

This repo was initialized from `charlie-labs/bun-lib-template`.

---

## Table of contents

- [Getting started](#getting-started)
- [Scripts](#scripts)
- [Project structure](#project-structure)
- [Development](#development)
- [Testing](#testing)
- [CI](#ci)
- [Configuration](#configuration)
- [Conventions](#conventions)
- [Keeping up to date](#keeping-up-to-date)
- [Releasing & publishing](#releasing--publishing)
- [License](#license)

---

## Getting started

### Prerequisites

- **Bun** 1.x (`curl -fsSL https://bun.sh/install | bash`)

### Setup

```bash
# Install dependencies
bun install

# Verify everything is wired
bun run typecheck
bun run lint
bun test
```

---

## Scripts

Common tasks (see `package.json` for the full list):

- `build`: `bun run --bun zshy` — runs the `zshy` bundler (configured via the `"zshy"` field) to emit dual CJS/ESM bundles
- `ci`: `bun run typecheck && bun run lint && bun run test`
- `fix`: `eslint --fix --quiet . ; prettier --write --log-level=silent .`
- `lint`: `eslint . && prettier --check .`
- `test`: `bun test`
- `typecheck`: `tsc --noEmit`

Usage:

```bash
bun run typecheck # TS type checks, no emit
bun run lint      # static analysis + Prettier check
bun run fix       # auto-fix lint + format issues
bun test      # unit tests with Bun
bun run build     # emit CJS/ESM bundles via zshy (see package.json#"zshy")
```

---

## Project structure

```
.
├─ src/
│  ├─ index.ts
│  └─ index.test.ts
├─ .github/workflows/
│  └─ ci.yml
├─ eslint.config.js
├─ knip.ts
├─ tsconfig.json
├─ bun.lock
├─ .prettierignore
├─ package.json
└─ README.md
```

> This project tracks the text-based `bun.lock` generated by `bun install --save-text-lock`. Run `bun install` after dependency changes to refresh it.

---

## Development

- **ESM-only**. Use explicit `.js` extensions on local imports when bundling TypeScript.
- Keep modules small and pure; push side effects to the entry point.
- Example pattern:

```ts
export function helloWorld(): string {
  return 'Hello World!';
}

if (import.meta.main) {
  console.log(helloWorld());
}
```

---

## Testing

- Tests run with `bun test`.
- Co-locate specs beside source (e.g., `src/index.test.ts`).

```ts
import { expect, test } from 'bun:test';
import { helloWorld } from './index.js';

test('helloWorld', () => {
  expect(helloWorld()).toBe('Hello World!');
});
```

---

## CI

- CI runs on PRs and the `master` branch.
- Workflow: `.github/workflows/ci.yml`
  - `bun install --frozen-lockfile`
  - `bun run build` to ensure `package.json` is current (via zshy)
  - `bun run ci` (typecheck, lint, test)

Badge at the top links to the current workflow run history.

> Prefer `main` as your default branch? Rename it (`git branch -m master main`) and update the badge + workflow triggers.

---

## Configuration

This template avoids runtime envs by default. If you need them:

1. Define a schema (e.g., Zod) and validate at startup.
2. Document required variables here.

Example:

```ts
export interface AppConfig {
  port: number;
}

export function loadConfig(env = process.env): AppConfig {
  const port = Number(env.PORT ?? '3000');
  if (!Number.isFinite(port) || port <= 0) {
    throw new Error('PORT must be a positive integer');
  }
  return { port };
}
```

---

## Conventions

- **Formatting/linting**: ESLint + Prettier (`bun run lint`, `bun run fix`)
- **Type safety**: `bun run typecheck` locally and in CI
- **Commits/PRs**: Keep PRs focused; include tests or rationale for behavior changes.

---

## Keeping up to date

If you enable the optional weekly “template sync” automation, shared files (e.g., `ci.yml`, `eslint.config.js`, `knip.ts`, `tsconfig.json`, `.prettierignore`) will be proposed via PR. Review and merge as needed. Project-specific code is never auto-overwritten.

---

## Releasing & publishing

This repo is set up to auto-publish to npm on merge to the default branch (currently `master`) via GitHub Actions. You only need to bump the version and merge a PR.

1. Create a branch and bump the version in `package.json` without creating a git tag:

   ```bash
   # pick one: patch | minor | major | or an explicit version
   npm version patch --no-git-tag-version
   # or: npm version 0.0.13 --no-git-tag-version
   ```

2. Commit the change and open a PR. Keep the PR limited to the version bump and any release notes you want in the description.

3. When the PR is merged to the default branch, the workflow at `.github/workflows/release.yml` will:

   - run typecheck and ESLint
   - publish to npm if the version is new (requires `NPM_TOKEN`)
   - create a GitHub Release with generated notes

Notes:

- Don’t push git tags manually; the workflow creates the tag during the GitHub Release step.
- If no new version is present (i.e., `package.json` didn’t change), the publish step is skipped and no release is created.
- The publish step skips npm lifecycle scripts; typecheck and lint run explicitly in the workflow.

### npm auth for the GitHub workflow

To publish to npm from GitHub Actions, add an npm access token as a secret named `NPM_TOKEN`:

1. Create an npm access token with at least “Publish” permission in your npm account settings.
2. In this repository’s Settings → Secrets and variables → Actions, add a new Repository secret named `NPM_TOKEN` with that token’s value. An Organization secret works too.
3. Nothing else is required—our release workflow already:
   - requests `id-token: write` for npm provenance support, and
   - uses `actions/setup-node@v4` to provide a recent npm version during publish.

If your org enforces “Require provenance” on npm, the existing `provenance: true` input on the publish step satisfies it.

---

## License

Update this section once you choose a license for your project.
